name: Deploy

on:
  workflow_dispatch:
  push:
    branches:
      - dev
      - qa
      - main
    paths:
      - infra/**  # Trigger on changes in the infra directory
      - frontend/**  # Trigger on changes in the frontend directory
      - backend/**  # Trigger on changes in the backend directory
      - .github/workflows/deploy.yaml  # Trigger on changes to this workflow file

permissions:
  id-token: write  # Required for OIDC authentication
  contents: read   # Default permission for accessing the repo

jobs:
  # Step 1: Bootstrap Backend Resources (if not already done)
  backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    environment: ${{ github.ref_name }}  # Use the branch name as environment
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure using OIDC
        uses: azure/login@v2
        with:
          client-id:        ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id:        ${{ secrets.AZURE_TENANT_ID }}
          subscription-id:  ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Create backend resources
        run: |
          # Define variables for the backend resources
          az_backend_rg_name="${{ vars.AZURE_BKD_RGROUP_NAME }}"
          az_backend_sa_name="${{ vars.AZURE_BKD_SA_NAME }}"
          az_backend_container_name="${{ vars.AZURE_BKD_CONTAINER_NAME }}"
          az_location="${{ vars.AZURE_LOCATION }}"
          
          # Create resource group if it doesn't exist
          az group create --name $az_backend_rg_name --location $az_location

          # Create storage account if it doesn't exist
          az storage account create \
            --name $az_backend_sa_name \
            --resource-group $az_backend_rg_name \
            --location $az_location \
            --sku Standard_LRS

          # Adding a small delay to ensure the storage account is fully provisioned
          sleep 15

          # Get the storage account key
          STORAGE_KEY=$(az storage account keys list --resource-group $az_backend_rg_name --account-name $az_backend_sa_name --query '[0].value' -o tsv)

          # Create storage container if it doesn't exist
          az storage container create \
            --name $az_backend_container_name \
            --account-name $az_backend_sa_name \
            --account-key $STORAGE_KEY
  
  # Main Terraform Deployment
  deploy:
    name: Deploy Environment
    runs-on: ubuntu-latest
    needs: backend  # Ensure backend resources are created first
    environment: ${{ github.ref_name }}  # Use the branch name as environment
    
    # define output variables for the backend job
    outputs:
      deployment_token: ${{ steps.tf_outputs.outputs.api_key }}
      app_hostname: ${{ steps.tf_outputs.outputs.hostname }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure using OIDC
        uses: azure/login@v2
        with:
          client-id:        ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id:        ${{ secrets.AZURE_TENANT_ID }}
          subscription-id:  ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set Terraform Environment Variables
        run: |
          echo "TF_VAR_az_client_id=${{ secrets.AZURE_CLIENT_ID }}" >> $GITHUB_ENV
          echo "TF_VAR_az_tenant_id=${{ secrets.AZURE_TENANT_ID }}" >> $GITHUB_ENV
          echo "TF_VAR_az_subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" >> $GITHUB_ENV
          echo "TF_VAR_az_container_name=${{ vars.AZURE_BKD_CONTAINER_NAME }}" >> $GITHUB_ENV
          echo "TF_VAR_repository_token=${{ secrets.AZURE_REPOSITORY_TOKEN }}" >> $GITHUB_ENV
  
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
  
      - name: Terraform Init
        working-directory: ./infra  # Update the working directory to the new infra folder
        env:
          ARM_CLIENT_ID:        ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID:  ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID:        ${{ secrets.AZURE_TENANT_ID }}
          ENVIRONMENT:          ${{ github.ref_name }}
          ARM_USE_OIDC: true
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ vars.AZURE_BKD_RGROUP_NAME }}" \
            -backend-config="storage_account_name=${{ vars.AZURE_BKD_SA_NAME }}" \
            -backend-config="container_name=${{ vars.AZURE_BKD_CONTAINER_NAME }}" \
            -backend-config="key=archie-${{ github.ref_name }}.tfstate"
  
      - name: Terraform Apply
        working-directory: ./infra  # Update the working directory to the new infra folder
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
          ENVIRONMENT: ${{ github.ref_name }}
        run: |
          echo "Using environment: ${{ github.ref_name }}"
          terraform apply -var-file="${{ github.ref_name }}.tfvars" -auto-approve

      - name: Get Terraform Outputs
        working-directory: ./infra # Update the working directory to the new infra folder
        id: tf_outputs
        run: |
          echo "Attempting to get Terraform outputs..."
          # Attempt to get outputs, redirect stderr to stdout to capture errors
          api_key_val=$(terraform output -raw static_web_app_api_key 2>&1)
          tf_output_exit_code=$? # Capture exit code of terraform output

          hostname_val=$(terraform output -raw static_web_app_default_host_name 2>&1)
          # You might want to capture and check hostname_val's exit code too if it's critical

          echo "Terraform output exit code for api_key: $tf_output_exit_code"
          echo "Raw api_key_val from terraform output: $api_key_val" # Print what TF actually returned

          # Check if the terraform output command failed OR if the output is empty/null
          if [ $tf_output_exit_code -ne 0 ] || [ -z "$api_key_val" ] || [ "$api_key_val" == "null" ]; then
            echo "::error::Failed to get valid static_web_app_api_key from Terraform output."
            echo "Terraform output command returned exit code: $tf_output_exit_code"
            echo "Output received: $api_key_val"
            exit 1 # Fail the job
          fi

          echo "Successfully retrieved api_key."
          # Set GitHub Actions step outputs
          echo "api_key=$api_key_val" >> $GITHUB_OUTPUT
          echo "hostname=$hostname_val" >> $GITHUB_OUTPUT # Assuming hostname retrieval is less critical or checked separately

          # Mask the API key in logs *after* ensuring it's valid
          echo "Masking retrieved API key."
          echo "::add-mask::$api_key_val"
  
  # Step 3: Build and Deploy Application to Static Web App
  build_and_deploy_app:
    name: Deploy App
    runs-on: ubuntu-latest
    needs: deploy # Run after infrastructure is deployed/updated
    environment: ${{ github.ref_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Azure Static Web App
        id: swa_deploy
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ needs.deploy.outputs.deployment_token }}
          action: "upload"
          app_location: "/frontend"  # Path to your frontend app
          api_location: "/backend"  # Path to your backend API
          output_location: "build"  # Path to the build output directory               

  # Step 4: Report Deployment URL
  report_url:
    name: Report
    runs-on: ubuntu-latest
    needs: [deploy, build_and_deploy_app] # Depends on both infra and app deployment
    steps:
      - name: Display Deployed URL
        run: |
          echo "------------------------------------------------------------------"
          echo "âœ… Application deployed successfully!"
          echo "Branch: ${{ github.ref_name }}"
          echo "URL: https://${{ needs.deploy.outputs.app_hostname }}"
          echo "------------------------------------------------------------------"